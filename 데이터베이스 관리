Reorg : 일종의 디스크 모음, DB 의 데이터블록을 효율적으로 관리하여 최적의 성능을 만들어주는 방법
 : ALTER TABLE MOVE 명령어를 이용해서 빈 공간이 없도록 사용했지만 Oracle 10g 부터 Reorg 기술 지원을 통해 단편화를 해소.
 * DB 의 성능을 저하시키는 문제는 HWM(고수위, High Water Mark)
 
 Partitioning 
  - 큰 TABLE 이나 INDEX를 관리하기 쉬운 단위로 분리하는 방법
  - 보통 연속적인 숫자나 날짜를 기준으로 Partitioning 한다
  - 손쉬운 관리 기법 제공에 따른 관리 시간의 단축
  - 우편번호 / 일별 / 월별 / 분기별등의 데이터에 적합한 방법
 
 Partitioning Benefit
  - 가용성 : 물리적인 Partitioning 으로 인해 전체 데이터의 훼손 가능성이 줄어들고, 데이터 가용성이 향상된다.
  - 관리용이성 : 큰 TABLE 들을 제거하여 관리를 쉽게해준다.
  - 성능 : 특정 DML 과 Query 의 성능을 향상시킨다.
  - 단점 : TABLE 간의 JOIN 에 대한 비용이 증가한다.
           TABLE 과 INDEX 를 별도로 Partition 할 수는 없다.
           TABLE 과 INDEX 를 같이 Partitioning 해야한다.

HWM(고수위, High Water Mark)
 - Extent 확장의 기준, 모든 Segment 에 하나씩 존재
 - 1 번에 5 개의 데이터 블록 단위로 HWM 이동
 - Full Scan 수행 시, HWM 앞의 모든 데이터 블록을 액세스
 - Data 가 적은데, Full Scan 시간이 오래 걸리면 Segment 축소 필요
 
 DELETE 와 TRUNCATE 의 차이점 
  - DELETE 는 데이터를 삭제해도 기존에 할당 된 영역 및 HWM 의 위치가 그대로이다.
  - TRUNCATE 는 자동 COMMIT
  - TRUNCATE 는 HWM 을 초기화 시킨다.
  - TRUNCATE 는 MinExtents 설정 값만큼을 제외하고 남은 Extents 는 모두 할당 해제한다.
  * 전체 데이터를 삭제 시, DELETE 보다 TRUNCATE 를 사용하는 것이 성능면에서 유리하다.

=========================================================================================
2020.01.20
INDEX : 관계형 데이터베이스에서 검색 속도를 높이기 위해서 사용하는 하나의 자료 구조, INDEX 는 색인으로써 해당 TALBE 의 컬럼을
 색인화(따로 파일로 저장)하여 검색 시, 해당 TABLE 의 레코드를 Full-Scan 하는게 아니라 색인화 되어있는 INDEX 파일을 검색하여 속도를 향상 시킨다.
 이런 INDEX 는 Tree 구조로 색인화한다.
 
INDEX 의 원리
 - INDEX 를 해당 컬럼에 주게 되면 초기 TABLE 생성 시 만들어진 MYD, MYI, FRM 3개의 파일 중에서 MYI 에 해당 컬럼을 색인화하여 저장.
 - 물론 INDEX 를 사용안할 경우 MYI 파일은 비어 있다. 그렇기에 INDEX 를 해당 컬럼에 만들게 되면 해당컬럼을 따로 인덱싱하여 MYI 파일에 입력한다.
 - 사용자가 SELECT 쿼리로 INDEX 가 사용하는 쿼리를 사용하면 해당 TABLE 을 검색하는 것이 아니라 Tree 로 정리해둔 MYI 파일의 내용을 검색
 
 INDEX 의 장점
  - KEY 값을 기초로 하여 테이블에서 검색과 정렬 속도를 향상
  - 질의 또는 보고서에서 그룹화 작업의 속도를 향상
		- INDEX 를 사용하면 테이블 행의 고유성을 강화시킬 수 있다.
		- 테이블의 기본 키는 자동으로 INDEX 된다.
		- 필드 중에서 데이터 형식때문에 INDEX 될 수 없는 필드도 존재한다.
		- 여러 필드로 이루어진(다중 필드) INDEX 를 사용하면 첫 필드 값이 같은 레코드도 구분할 수 있다.
		- 다중 필드 INDEX 는 최대 10개의 필드를 포함할 수 있다.
 
 INDEX 의 단점
  - INDEX 를  만들면 .mdb 파일 크기가 늘어난다.
		- 여러 사용자 응용 프로그램에서의 여러 사용자가 한 페이지를 동시에 수정할 수 있는 병행성이 줄어든다/
		- INDEX 된 필드에서 데이터를 업데이트하거나, 레코드를 추가 또는 삭제할 때 성능이 떨어진다/
		- INDEX 가 데이터베이스 공간을 차지해 추가적인 공간이 필요해진다. (DB의 10% 내외의 공간이 추가로 필요)
		- INDEX 를 생성하는 데 시간이 많이 소요될 수 있다.
		- 데이터 변경 작업이 자주 일어날 경우 INDEX 를 재작성해야 할 필요가 있기에 성능에 영향을 미칠 수 있다.
  
  * 만드는 쿼리의 종류와 관계없이 가장 고유한 값을 갖는 필드만 INDEX 해야 효율성이 증가한다.
  
 INDEX 의 목적
  - 관계형 데이터베이스에서 INDEX 의 목적은 검색 속도를 높이는 데 있다. SELECT 쿼리의 WHERE 절이나 JOIN 예약어를 사용했을 때만
		  INDEX 를 사용하며, SELECT 쿼리의 검색 속도를 빠르게 하는데 목적을 두고 있다
* INSERT / UPDATE / DELETE 쿼리에는 해당 사항이 없으며 INDEX 사용 시, 속도가 감소한다.
 
 주의 사항
 - SELECT 하는 경우에도 데이터 블록 수와 DB_FILE_MULTIBLOCK_READ_COUNT 값과 분포도 등에 따라 INDEX 가 빠를 경우도 있고
   Full-Scan 보다 늦는 경우 발생
  - DML에 취약함
    : INSERT
    - Index Split 현상이 발생할 수 있다(INDEX 의 Block 들이 하나에서 두 개로 나누어지는 현상)

    : DELETE
    - TABLE 에서 데이터가 지워질 경우 해당 데이터가 지워지고 다른 데이터가 그 공간을 하지만 
      INDEX에서 데이터가 지워질 경우 해당 데이터가 지워지지 않고, 사용 안됨 표시만 해둔다.

    : UPDATE
    - 수정할 경우 INDEX 에서는 DELETE 가 먼저 발생한 후, 새로운 작업의 INSERT 작업이 발생하므로 부하 증가
 
생성 방법
 - 자동 생성 : Primary Key 또는 Unique 제약 조건을 정의할 경우 Unique Index 가 자동으로 생성된다 
 - Unique Index : INDEX 안에 있는 KEY 값에 중복 데이터 발생 X
   Create Unique Index 인덱스명
   ON 테이블 이름(컬럼명 ASC/DESC, 칼럼명 ASC/DESC,...)

 - Non Unique Index : INDEX 안에 있는 KEY 값의 중복 가능
   Create Index 인덱스명
   ON 테이블 이름(컬럼명 ASC/DESC, 칼럼명 ASC/DESC,...) 
   
=========================================================================================
2020.01.20
WITH 구문
 - WITH 구문 내의 쿼리의 결과(SUB Query)가 여러 번 사용될 때 유용하다.
 - Sub Query Block 에 이름을 지정할 수 있도록 해준다.
 - 오라클 옵티마이저는 쿼리를 인라인 뷰 또는 임시 테이블로 여긴다.
 - Oracle 9 이상 지원
    
WITH 구문 사용방법 
 - WITH alias명 AS ( SUB Query )
   SELECT column명 FROM alias명;
   WITH aa AS
   ( SELECT * FROM DUAL )
   SELECT * FROM aa;
     
 2개 이상 WITH 구문 사용방법
  - WITH alias명 AS ( SUB Query )
  	alias명2 AS ( SUB Query2 )
    SELECT column명 FROM alias명 WHERE 조인조건;
